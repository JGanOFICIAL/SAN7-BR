<!-- WIDGET DE CHAMADA (incorporável) -->
<style>
  /* estilos modernos e limpos — projetado para incorporar */
  :root{
    --bg:#ffffff;
    --card:#fbfcfe;
    --accent:#0b6cff;
    --muted:#6b7280;
    --danger:#ef4444;
    --success:#10b981;
    --glass: rgba(11,108,255,0.06);
    --shadow: 0 6px 18px rgba(11,24,40,0.06);
    --radius:12px;
    font-family: Inter, "Segoe UI", Roboto, Arial, sans-serif;
  }
  .call-widget{
    width:100%;
    max-width:420px;
    background:var(--card);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:18px;
    box-sizing:border-box;
    border:1px solid rgba(15,23,42,0.04);
  }
  .cw-header{
    display:flex;
    gap:12px;
    align-items:center;
  }
  .brand{
    width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#6fb3ff);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;font-size:18px;
  }
  .title{font-size:16px;font-weight:700;color:#071033;}
  .subtitle{font-size:12px;color:var(--muted);}
  .form{margin-top:12px;display:flex;flex-direction:column;gap:10px;}
  .input{padding:12px;border-radius:10px;border:1px solid rgba(11,23,40,0.06);background:transparent;font-size:14px;}
  .row{display:flex;gap:8px;}
  .btn{
    padding:12px;border-radius:10px;border:0;background:var(--accent);color:white;font-weight:700;cursor:pointer;
    box-shadow:0 6px 14px rgba(11,108,255,0.12);
  }
  .btn.ghost{background:transparent;color:var(--accent);border:1px solid rgba(11,108,255,0.12);box-shadow:none;}
  .status-card{margin-top:12px;padding:12px;border-radius:10px;background:linear-gradient(180deg, rgba(11,108,255,0.04), rgba(11,108,255,0.02));display:none;}
  .protocol{font-weight:800;letter-spacing:1px;font-size:18px;color:#05204a;}
  .muted{color:var(--muted);font-size:13px;}
  .controls{display:flex;gap:8px;margin-top:12px;}
  .danger{background:var(--danger);color:#fff;}
  .small{font-size:13px;padding:8px 10px;border-radius:8px;}
  .timeline{margin-top:10px;font-size:13px;color:var(--muted);}
  .ping{font-size:12px;color:var(--muted);margin-top:8px;}
  audio{display:block;width:1px;height:1px;opacity:0;position:absolute;left:-9999px;}
  @media(max-width:480px){
    .call-widget{padding:14px;border-radius:10px;}
  }
</style>

<div class="call-widget" id="callWidget">
  <div class="cw-header">
    <div class="brand">SA</div>
    <div>
      <div class="title">Central de Atendimento</div>
      <div class="subtitle">Atendimento em tempo real — fale com o suporte</div>
    </div>
  </div>

  <div id="formArea" class="form" aria-live="polite">
    <input id="nomeInput" class="input" placeholder="Nome completo" autocomplete="name">
    <input id="cpfInput" class="input" placeholder="CPF (apenas números ou formatado)" inputmode="numeric">
    <div class="row">
      <button id="startBtn" class="btn">Iniciar atendimento</button>
      <button id="howBtn" class="btn ghost" type="button">Como funciona</button>
    </div>
    <div class="muted" style="margin-top:6px">Ao iniciar, será solicitado acesso ao microfone.</div>
  </div>

  <div id="waitingArea" class="status-card" role="status">
    <div><span class="protocol" id="protocolTxt">Protocolo: —</span></div>
    <div class="muted" id="waitingMsg">Aguardando atendente. Por favor aguarde! Pode levar alguns minutos.</div>
    <div class="timeline" id="timeline">Criado em: —</div>
    <div class="ping" id="pingStatus">Conexão: —</div>
    <div class="controls">
      <button id="cancelBtn" class="btn small ghost">Cancelar solicitação</button>
    </div>
    <audio id="remoteAudio" autoplay playsinline></audio>
  </div>

  <div id="inCallArea" class="status-card" style="display:none">
    <div class="protocol">Em chamada — protocolo: <span id="callProtocol">—</span></div>
    <div class="muted" id="callWith">Atendido por: —</div>
    <div class="muted" id="callTimer">Tempo: 00:00</div>
    <div class="controls">
      <button id="hangBtn" class="btn danger small">Desligar</button>
    </div>
    <audio id="remoteAudioInCall" autoplay playsinline></audio>
  </div>
</div>

<!-- firebase + script.js (conforme solicitado) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script src="script.js"></script>

<script>
/* WIDGET client-side glue */
(() => {
  const startBtn = document.getElementById('startBtn');
  const howBtn = document.getElementById('howBtn');
  const cancelBtn = document.getElementById('cancelBtn');
  const hangBtn = document.getElementById('hangBtn');
  const formArea = document.getElementById('formArea');
  const waitingArea = document.getElementById('waitingArea');
  const inCallArea = document.getElementById('inCallArea');
  const protocolTxt = document.getElementById('protocolTxt');
  const waitingMsg = document.getElementById('waitingMsg');
  const timeline = document.getElementById('timeline');
  const pingStatus = document.getElementById('pingStatus');
  const remoteAudio = document.getElementById('remoteAudio');
  const remoteAudioInCall = document.getElementById('remoteAudioInCall');
  const callProtocolSpan = document.getElementById('callProtocol');
  const callWith = document.getElementById('callWith');
  const callTimer = document.getElementById('callTimer');

  let localStream = null;
  let currentCallRef = null;
  let protocolId = null;
  let callerPC = null;
  let callStartTs = null;
  let callTimerInterval = null;
  let pingInterval = null;

  function formatDate(ts){
    const d=new Date(ts);
    return d.toLocaleString();
  }
  function startTimer(){
    if(callTimerInterval) clearInterval(callTimerInterval);
    callTimerInterval = setInterval(()=>{
      if(!callStartTs) return;
      const diff = Math.floor((Date.now()-callStartTs)/1000);
      const mm = String(Math.floor(diff/60)).padStart(2,'0');
      const ss = String(diff%60).padStart(2,'0');
      callTimer.textContent = `Tempo: ${mm}:${ss}`;
    },1000);
  }
  function stopTimer(){ clearInterval(callTimerInterval); callTimerInterval=null; callTimer.textContent='Tempo: 00:00'; }

  async function requestMicrophone(){
    try{
      localStream = await navigator.mediaDevices.getUserMedia({audio:true});
      // local stream not played locally to avoid echo
      return true;
    }catch(e){
      alert('Permissão de microfone negada. Para usar o atendimento, permita o microfone.');
      return false;
    }
  }

  function genProtocol(){
    let s='';
    for(let i=0;i<12;i++) s+=Math.floor(Math.random()*10);
    return s;
  }

  async function startRequest(nome, cpf){
    // basic validation
    if(!nome || !cpf){ alert('Informe nome completo e CPF'); return; }
    if(!localStream){
      const ok = await requestMicrophone();
      if(!ok) return;
    }
    protocolId = genProtocol();

    // check duplicate by CPF
    const cpfNum = onlyDigits(cpf);
    const activeRef = db.ref('active_by_cpf/' + cpfNum);
    const snap = await activeRef.get();
    if(snap.exists()){
      alert('Já existe uma chamada ativa com este CPF neste momento.');
      return;
    }

    // build call node
    const callRef = db.ref('calls/' + protocolId);
    currentCallRef = callRef;

    const payload = {
      protocol: protocolId,
      nome: nome,
      cpf: cpf,
      status: 'waiting',
      createdAt: Date.now(),
      callerOnline: navigator.onLine,
      callerDevice: 'widget',
    };
    await callRef.set(payload);
    // set index for cpf -> active map
    await db.ref('active_by_cpf/' + cpfNum).set({protocol:protocolId, createdAt: Date.now()});

    // UI
    formArea.style.display='none';
    waitingArea.style.display='block';
    protocolTxt.textContent = 'Protocolo: ' + protocolId;
    timeline.textContent = 'Criado em: ' + formatDate(payload.createdAt);
    pingStatus.textContent = 'Conexão: ' + (navigator.onLine ? 'online' : 'offline');

    // listen for changes
    callRef.on('value', async snap=>{
      if(!snap.exists()) return;
      const data = snap.val();
      if(data.status === 'accepted' && data.adminId){
        // admin accepted -> start WebRTC negotiation
        waitingArea.style.display='none';
        inCallArea.style.display='block';
        callProtocolSpan.textContent = protocolId;
        callWith.textContent = 'Atendido por: ' + (data.adminName || 'Suporte');
        callStartTs = data.acceptedAt || Date.now();
        startTimer();

        await startCallerWebRTC(callRef, localStream, remoteAudioInCall);
      }else if(data.status === 'nao_atendido'){
        waitingMsg.textContent = 'Não atendido. Tente novamente depois.';
        // cleanup index after some seconds
        setTimeout(()=>cleanupCallNode(protocolId), 5000);
      }else if(data.status === 'canceled'){
        waitingMsg.textContent = 'Solicitação cancelada.';
        setTimeout(()=>cleanupCallNode(protocolId), 3000);
      }else if(data.status === 'ended'){
        // chamada encerrada pelo suporte
        stopCallUI();
      }
    });

    // ping updater
    pingInterval = setInterval(()=> {
      if(!currentCallRef) return;
      currentCallRef.update({callerPing: Date.now(), callerOnline: navigator.onLine});
    },5000);

    // auto-timeout: after 10 minutes -> nao_atendido
    setTimeout(async ()=>{
      const snapNow = await callRef.get();
      if(snapNow.exists()){
        const d = snapNow.val();
        if(d.status === 'waiting'){
          await callRef.update({status:'nao_atendido', endedAt: Date.now()});
          // cleanup index
          await db.ref('active_by_cpf/'+onlyDigits(cpf)).set(null);
        }
      }
    }, 10*60*1000);
  }

  async function cleanupCallNode(pid){
    if(!pid) return;
    const ref = db.ref('calls/' + pid);
    await ref.remove();
    // remove active_by_cpf entries that point to this pid
    const activeSnap = await db.ref('active_by_cpf').get();
    if(activeSnap.exists()){
      activeSnap.forEach(child=>{
        const v=child.val();
        if(v && v.protocol === pid) child.ref.set(null);
      });
    }
    stopCallUI();
  }

  function stopCallUI(){
    // stop pc and streams
    if(callerPC){ callerPC.close(); callerPC=null; }
    if(localStream){
      localStream.getTracks().forEach(t=>t.stop()); localStream=null;
    }
    if(currentCallRef){
      currentCallRef.off();
      currentCallRef=null;
    }
    if(pingInterval){ clearInterval(pingInterval); pingInterval=null; }
    protocolId=null;
    inCallArea.style.display='none';
    waitingArea.style.display='none';
    formArea.style.display='block';
    stopTimer();
  }

  async function cancelRequest(){
    if(!currentCallRef || !protocolId){
      // nothing
      formArea.style.display='block';
      waitingArea.style.display='none';
      return;
    }
    await currentCallRef.update({status:'canceled', endedAt: Date.now()});
    // cleanup index by CPF
    const data = (await currentCallRef.get()).val();
    if(data && data.cpf){
      await db.ref('active_by_cpf/'+onlyDigits(data.cpf)).set(null);
    }
    // remove node shortly
    setTimeout(()=>cleanupCallNode(protocolId), 1600);
  }

  async function hangCall(){
    if(!currentCallRef) return;
    await currentCallRef.update({status:'ended', endedAt: Date.now()});
    // remove node
    setTimeout(()=>cleanupCallNode(protocolId), 800);
  }

  // WebRTC caller flow (creates offer)
  async function startCallerWebRTC(callRef, stream, remoteAudioEl){
    // ensure node structure
    const offerRef = callRef.child('offer');
    const answerRef = callRef.child('answer');
    const callerIceRef = callRef.child('callerIce');
    const adminIceRef = callRef.child('adminIce');

    const configuration = {
      iceServers: [
        {urls: 'stun:stun.l.google.com:19302'},
        {urls: 'stun:stun1.l.google.com:19302'}
      ]
    };
    callerPC = new RTCPeerConnection(configuration);

    // add local tracks
    for(const t of stream.getTracks()) callerPC.addTrack(t, stream);

    // remote audio
    callerPC.addEventListener('track', (ev)=>{
      // attach remote stream
      remoteAudioEl.srcObject = ev.streams[0];
      remoteAudioEl.play().catch(()=>{});
    });

    // gather ICE
    callerPC.onicecandidate = (event)=>{
      if(event.candidate){
        callerIceRef.push(event.candidate.toJSON());
      }
    };

    // create offer
    const offer = await callerPC.createOffer();
    await callerPC.setLocalDescription(offer);
    await offerRef.set({sdp: offer.sdp, type: offer.type});

    // listen for answer
    answerRef.on('value', async snap=>{
      if(!snap.exists()) return;
      const a = snap.val();
      const answerDesc = {type: a.type || 'answer', sdp: a.sdp};
      await callerPC.setRemoteDescription(answerDesc);
    });

    // listen for ICE candidates from admin
    adminIceRef.on('child_added', (snap)=>{
      const cand = snap.val();
      callerPC.addIceCandidate(new RTCIceCandidate(cand)).catch(()=>{});
    });
  }

  // UI events
  startBtn.addEventListener('click', async ()=>{
    const nome = document.getElementById('nomeInput').value.trim();
    const cpf = document.getElementById('cpfInput').value.trim();
    await startRequest(nome, cpf);
  });
  cancelBtn.addEventListener('click', async ()=> {
    if(confirm('Deseja cancelar a solicitação?')) await cancelRequest();
  });
  hangBtn && hangBtn.addEventListener('click', async ()=> {
    if(confirm('Encerrar chamada?')) await hangCall();
  });

  howBtn.addEventListener('click', ()=> {
    alert('Ao clicar em "Iniciar atendimento" você autoriza o uso do microfone. Aguarde um atendente aceitar sua solicitação. Você poderá cancelar enquanto estiver em espera.');
  });

  // detect online/offline
  window.addEventListener('online', ()=> pingStatus.textContent='Conexão: online');
  window.addEventListener('offline', ()=> pingStatus.textContent='Conexão: offline');

})();
</script>

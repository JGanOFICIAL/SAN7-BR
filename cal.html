<!-- widget.html -->
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Central de Atendimento — Widget</title>
  <style>
    :root{
      --bg:#ffffff; --accent:#0b4b7a; --muted:#6b6b6b;
      --card-shadow: 0 8px 24px rgba(14,34,59,0.08);
      font-family: "Public Sans", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    html,body{height:100%;margin:0;background:var(--bg);}
    .widget{
      width:100%; max-width:420px; margin:12px auto; padding:18px;
      background: #fff; border-radius:12px; box-shadow:var(--card-shadow);
      border:1px solid rgba(11,75,122,0.04);
    }
    h1{font-size:18px;margin:0 0 12px;color:var(--accent)}
    label{display:block;font-size:13px;color:var(--muted);margin-top:10px}
    input[type="text"], input[type="tel"]{
      width:100%; padding:10px;border-radius:8px;border:1px solid #eee;font-size:15px;
      box-sizing:border-box;margin-top:6px;
    }
    .actions{display:flex;gap:8px;margin-top:14px}
    button{
      flex:1;padding:10px 12px;border-radius:8px;border:0;background:var(--accent);
      color:#fff;font-weight:600;cursor:pointer;
    }
    button.ghost{background:#f3f7fb;color:var(--accent);border:1px solid rgba(11,75,122,0.08)}
    .status{margin-top:14px;padding:12px;border-radius:8px;background:#fbfdff;border:1px solid #eef6fc;font-size:14px;color:#0b3b60}
    .small{font-size:13px;color:var(--muted)}
    .controls{display:flex;gap:8px;align-items:center;margin-top:12px}
    .call-controls{display:flex;gap:8px;margin-top:12px}
    audio{display:block;margin-top:10px;width:100%;}
    .center{display:flex;align-items:center;gap:8px}
    .badge{background:#e9f3ff;color:var(--accent);padding:6px 8px;border-radius:8px;font-weight:700}
    .overlay-tut{position:fixed;inset:0;background:rgba(8,10,14,0.5);display:none;align-items:center;justify-content:center;z-index:9999}
    .tut-box{background:#fff;padding:18px;border-radius:10px;max-width:720px;box-shadow:0 10px 40px rgba(2,6,23,0.3)}
  </style>
</head>
<body>
  <div class="widget" id="widgetRoot">
    <h1>Central de Atendimento</h1>
    <div id="formArea">
      <label>Nome completo</label>
      <input id="nome" type="text" placeholder="Seu nome completo" autocomplete="name"/>
      <label>CPF</label>
      <input id="cpf" type="tel" placeholder="000.000.000-00" autocomplete="off"/>
      <div class="actions">
        <button id="startBtn">Solicitar Atendimento</button>
        <button id="cancelBtn" class="ghost" style="display:none">Cancelar</button>
      </div>
      <div id="message" class="status" style="display:none"></div>
      <div id="callArea" style="display:none">
        <div class="small">Protocolo: <span id="proto" class="badge"></span></div>
        <div class="small" id="callStatus">Status: aguardando</div>
        <div class="call-controls" style="margin-top:8px">
          <button id="hangupBtn" style="background:#c0392b">Desligar</button>
        </div>
        <audio id="remoteAudio" autoplay></audio>
        <div class="small" id="callTimer">Duração: 00:00</div>
        <div class="small" id="pingStatus">Conexão: verificando...</div>
      </div>
    </div>
  </div>

  <div class="overlay-tut" id="tutorialOverlay">
    <div class="tut-box">
      <h3>Como será atendido</h3>
      <p>1. Aguarde até um suporte aceitar.<br>
         2. Ao aceitar, o áudio será conectado — fale normalmente.<br>
         3. Você pode cancelar antes do atendimento.<br>
         4. Se não houver atendimento em 10 minutos, aparecerá "não atendido".</p>
      <p><button id="closeTut">Fechar</button></p>
    </div>
  </div>

  <!-- Firebase compat + script.js (seu arquivo principal) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <script src="script.js"></script>

  <script>
    // widget UI logic - usa funções do script.js (calls API)
    (function(){
      const nomeEl = document.getElementById('nome');
      const cpfEl = document.getElementById('cpf');
      const startBtn = document.getElementById('startBtn');
      const cancelBtn = document.getElementById('cancelBtn');
      const message = document.getElementById('message');
      const callArea = document.getElementById('callArea');
      const protoEl = document.getElementById('proto');
      const callStatus = document.getElementById('callStatus');
      const hangupBtn = document.getElementById('hangupBtn');
      const remoteAudio = document.getElementById('remoteAudio');
      const callTimer = document.getElementById('callTimer');
      const pingStatus = document.getElementById('pingStatus');
      const tut = document.getElementById('tutorialOverlay');
      const closeTut = document.getElementById('closeTut');

      let currentCall = null;
      let callTimerInterval = null;

      closeTut.onclick = ()=> tut.style.display='none';

      async function requestMic(){
        try{
          await navigator.mediaDevices.getUserMedia({audio:true});
          return true;
        }catch(e){
          console.warn('Mic denied', e);
          return false;
        }
      }

      startBtn.addEventListener('click', async ()=>{
        const nome = nomeEl.value.trim();
        const cpf = cpfEl.value.trim();
        if(!nome || !cpf){ message.style.display='block'; message.textContent='Preencha nome e CPF.'; return; }
        message.style.display='none';

        // pedir microfone (para webviews pode abrir permissão)
        await requestMic();

        try{
          const res = await Calls.createCall({nomeCompleto:nome, cpf});
          // res = {protocol, status}
          currentCall = res;
          protoEl.textContent = res.protocol;
          callArea.style.display='block';
          cancelBtn.style.display='none';
          startBtn.style.display='none';
          callStatus.textContent = 'Status: aguardando atendente. Por favor aguarde! Pode levar alguns minutos';
          // start listening for updates
          Calls.listenCall(res.protocol, updateFromServer);
        }catch(err){
          message.style.display='block';
          message.textContent = err.message || String(err);
        }
      });

      cancelBtn.addEventListener('click', async ()=>{
        if(!currentCall) return;
        await Calls.cancelCall(currentCall.protocol, 'cancelled_by_user');
        resetUI();
      });

      hangupBtn.addEventListener('click', async ()=>{
        if(!currentCall) return;
        await Calls.endCall(currentCall.protocol, 'ended_by_user');
        resetUI();
      });

      function resetUI(){
        currentCall = null;
        callArea.style.display='none';
        startBtn.style.display='block';
        cancelBtn.style.display='none';
        protoEl.textContent='';
        callTimer.textContent='Duração: 00:00';
        pingStatus.textContent='Conexão: -';
      }

      function updateFromServer(callData){
        // callData is entire call object from DB
        if(!callData) { resetUI(); return; }
        const status = callData.status;
        callStatus.textContent = `Status: ${status}`;
        // if in call -> show audio element and play
        if(status === 'in_call'){
          // attach remote stream if available (handled by Calls lib)
          remoteAudio.srcObject = Calls.getRemoteStream();
          // start timer
          startTimer(callData.startedAt || Date.now());
          cancelBtn.style.display='none';
        }else if(status === 'waiting'){
          cancelBtn.style.display='block';
        }else if(status === 'no_answer' || status === 'cancelled' || status === 'ended' || status === 'rejected'){
          // final statuses -> reset after small delay
          setTimeout(resetUI, 2000);
        }
        // ping heartbeat
        if(callData.heartbeat){
          const otherPing = callData.heartbeat.support || callData.heartbeat.client;
          if(otherPing){
            pingStatus.textContent = 'Conexão: OK';
          }
        }
      }

      function startTimer(startTs){
        clearInterval(callTimerInterval);
        function update(){
          const diff = Math.max(0, Date.now() - startTs);
          const mm = String(Math.floor(diff/60000)).padStart(2,'0');
          const ss = String(Math.floor((diff%60000)/1000)).padStart(2,'0');
          callTimer.textContent = `Duração: ${mm}:${ss}`;
        }
        update();
        callTimerInterval = setInterval(update, 1000);
      }

      // Expor para debug
      window._widgetDebug = {resetUI};
    })();
  </script>
</body>
</html>

<!-- widget.html (incorporável) -->
<!-- Obs: intencionalmente sem <!DOCTYPE> conforme solicitado -->
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Central de Atendimento - Widget</title>

  <link href="https://fonts.googleapis.com/css2?family=Public+Sans:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#ffffff;
      --card:#f7f8fa;
      --accent:#0b3b66;
      --muted:#6b7280;
      --success:#0b8a4a;
    }
    html,body{height:100%;margin:0;font-family:'Public Sans',system-ui,Segoe UI,Roboto,Arial;}
    .widget-wrap{background:var(--bg);color:#111;padding:18px;border-radius:12px;box-shadow:0 6px 22px rgba(10,20,30,0.06);max-width:420px;min-width:300px;}
    h1{margin:0 0 8px;font-size:18px;color:var(--accent);}
    p.lead{margin:0 0 14px;color:var(--muted);font-size:13px}
    .form-row{display:flex;flex-direction:column;gap:8px;margin-bottom:12px}
    input[type="text"], input[type="tel"]{
      padding:10px 12px;border:1px solid #e6e9ef;border-radius:8px;font-size:14px;outline:none;
    }
    button{background:var(--accent);color:#fff;border:0;padding:10px 12px;border-radius:10px;font-weight:600;cursor:pointer;}
    .btn-ghost{background:transparent;border:1px solid #e6e9ef;color:var(--accent)}
    .center{display:flex;gap:8px;align-items:center}
    .protocol{font-weight:700;color:var(--accent);font-size:14px}
    .status{margin-top:10px;padding:12px;border-radius:10px;background:var(--card);font-size:14px}
    .small{font-size:13px;color:var(--muted)}
    .actions{display:flex;gap:8px;margin-top:10px}
    .hint{margin-top:8px;font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="widget-wrap" id="widget">
    <h1>Central de Atendimento</h1>
    <p class="lead">Por favor, informe seu nome completo e CPF para gerar um protocolo.</p>

    <div id="formArea">
      <div class="form-row">
        <input id="nomeInput" type="text" placeholder="Nome completo" />
        <input id="cpfInput" type="tel" placeholder="CPF (somente números ou formatado)" />
      </div>
      <div class="center">
        <button id="startBtn">Iniciar Atendimento</button>
        <button class="btn-ghost" id="micTestBtn" type="button">Testar microfone</button>
      </div>
      <div class="hint">Ao entrar será solicitado acesso ao microfone.</div>
    </div>

    <div id="waitingArea" style="display:none;">
      <div class="status">
        <div>Protocolo: <span class="protocol" id="protocolLabel">—</span></div>
        <div style="margin-top:8px;" id="waitingMsg">Aguardando atendente. Por favor aguarde! Pode levar alguns minutos.</div>
        <div class="hint small" id="timerHint">Tempo aguardando: <span id="elapsed">00:00</span></div>
        <div class="actions">
          <button id="cancelBtn" class="btn-ghost">Cancelar solicitação</button>
        </div>
      </div>
    </div>

    <div id="inCallArea" style="display:none;">
      <div class="status">
        <div id="callInfo">Conectado ao suporte — duração: <span id="callTimer">00:00</span></div>
        <div style="margin-top:10px;">
          <button id="hangupBtn" class="btn-ghost">Desligar</button>
        </div>
      </div>
    </div>

    <div id="resultMsg" style="display:none;margin-top:12px;font-size:13px;color:var(--muted)"></div>
  </div>

  <!-- Firebase compat libs and script.js -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <script src="script.js"></script>

  <script>
    // Widget-specific wiring (usa funções de script.js)
    (function(){
      const nomeInput = document.getElementById('nomeInput');
      const cpfInput = document.getElementById('cpfInput');
      const startBtn = document.getElementById('startBtn');
      const micTestBtn = document.getElementById('micTestBtn');
      const waitingArea = document.getElementById('waitingArea');
      const formArea = document.getElementById('formArea');
      const protocolLabel = document.getElementById('protocolLabel');
      const cancelBtn = document.getElementById('cancelBtn');
      const inCallArea = document.getElementById('inCallArea');
      const hangupBtn = document.getElementById('hangupBtn');
      const resultMsg = document.getElementById('resultMsg');
      const waitingMsg = document.getElementById('waitingMsg');
      const elapsed = document.getElementById('elapsed');
      const callTimer = document.getElementById('callTimer');

      let protocolId = null;
      let waitingStartedAt = 0;
      let waitingInterval = null;
      let callStartedAt = 0;
      let callInterval = null;

      async function askMicOnEnter(){
        try{
          await navigator.mediaDevices.getUserMedia({ audio:true });
          // não usamos stream imediatamente; só pedimos permissão
        }catch(e){
          console.warn('Microfone não permitido', e);
        }
      }

      askMicOnEnter();

      micTestBtn.addEventListener('click', async ()=>{
        try{
          const s = await navigator.mediaDevices.getUserMedia({ audio:true });
          // breve teste: apenas abrir e fechar
          s.getTracks().forEach(t=>t.stop());
          alert('Microfone acessível.');
        }catch(e){
          alert('Falha ao acessar microfone. Permita o microfone no navegador.');
        }
      });

      startBtn.addEventListener('click', async ()=>{
        const nome = nomeInput.value.trim();
        const cpf = cpfInput.value.trim();
        if(!nome || !cpf){ alert('Preencha nome e CPF'); return; }
        // gerar protocolo de 12 dígitos
        function genProtocol(){ return ('' + Math.floor(100000000000 + Math.random()*900000000000)); }
        protocolId = genProtocol();

        // cria chamado no Firebase (usa função global createCall)
        try{
          await createCall({
            protocol: protocolId,
            nomeCompleto: nome,
            cpf: cpf
          });
        }catch(err){
          console.error(err);
          alert('Erro ao criar solicitação.');
          return;
        }

        protocolLabel.textContent = protocolId;
        formArea.style.display = 'none';
        waitingArea.style.display = 'block';
        resultMsg.style.display = 'none';
        waitingStartedAt = Date.now();
        elapsed.textContent = '00:00';
        waitingInterval = setInterval(()=>{
          const sec = Math.floor((Date.now()-waitingStartedAt)/1000);
          const mm = String(Math.floor(sec/60)).padStart(2,'0');
          const ss = String(sec%60).padStart(2,'0');
          elapsed.textContent = mm+':'+ss;
        },1000);

        // passar a UI para escutar status da chamada:
        subscribeToCall(protocolId, {
          onOffer: async (offer) => {
            // suporte já aceitou e criou offer -> seremos callee: responder (answer)
            waitingMsg.textContent = 'Conectando ao suporte...';
            try{
              await handleIncomingOfferAsCallee(protocolId, offer, {
                onStartCall: ()=>{
                  // switch UI
                  waitingArea.style.display = 'none';
                  inCallArea.style.display = 'block';
                  callStartedAt = Date.now();
                  callInterval = setInterval(()=>{
                    const sec = Math.floor((Date.now()-callStartedAt)/1000);
                    const mm = String(Math.floor(sec/60)).padStart(2,'0');
                    const ss = String(sec%60).padStart(2,'0');
                    callTimer.textContent = mm+':'+ss;
                  },1000);
                },
                onEnded: ()=>{
                  cleanupAfterCall('A chamada foi encerrada.');
                }
              });
            }catch(e){
              console.error('Erro ao responder offer', e);
              cleanupAfterCall('Erro na conexão de áudio.');
            }
          },
          onRemoved: ()=>{
            // pedido removido (recusado ou encerrado). Exibir mensagem.
            cleanupAfterCall('Pedido removido pelo suporte.');
          },
          onStatusChange: (status)=>{
            if(status === 'not_answered'){
              cleanupAfterCall('Não atendido (tempo esgotado).');
            }
          }
        });

      });

      cancelBtn.addEventListener('click', async ()=>{
        if(!protocolId) return;
        try{
          await cancelCall(protocolId);
        }catch(e){ console.warn(e); }
        cleanupAfterCall('Solicitação cancelada por você.');
      });

      hangupBtn.addEventListener('click', async ()=>{
        if(!protocolId) return;
        try{
          await hangupCall(protocolId);
        }catch(e){ console.warn(e); }
        cleanupAfterCall('Chamada encerrada.');
      });

      function cleanupAfterCall(message){
        protocolId = null;
        if(waitingInterval){ clearInterval(waitingInterval); waitingInterval = null;}
        if(callInterval){ clearInterval(callInterval); callInterval=null;}
        formArea.style.display = 'block';
        waitingArea.style.display = 'none';
        inCallArea.style.display = 'none';
        resultMsg.style.display = 'block';
        resultMsg.textContent = message;
      }

    })();
  </script>
</body>
</html>
